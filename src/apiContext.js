import axios from "axios";
import fs from "fs";
import path from "path";
import getCsrfToken from "./getCsrfToken.js";

const url = "https://apis.roblox.com/cloud-authentication/v1/apiKey";

/**
 * Creates a new API context using the provided ROBLOSECURITY cookie.
 * @param {string} roblosecurity The ROBLOSECURITY cookie value.
 * @returns The created API context, or undefined on failure.
 */
export async function createApiContext(roblosecurity) {
    const csrfToken = await getCsrfToken(url, roblosecurity);
    if (!csrfToken) {
        console.error("Failed to get CSRF token");
        return;
    }

    // Generate a random hash for the API key name
    const randomHash = Math.random().toString(36).substring(2, 12);
    const payload = {
        cloudAuthUserConfiguredProperties: {
            name: `robloxluauexecute_${randomHash}`,
            description: "Generated by roblox-luau-execute",
            isEnabled: true,
            allowedCidrs: ["0.0.0.0/0"],
            scopes: [
                { scopeType: "asset-permissions", targetParts: ["*"], operations: ["write"] },
                { scopeType: "asset", targetParts: ["*"], operations: ["write", "read"] },
                { scopeType: "creator-store-product", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "game-pass", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "developer-product", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "group", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "user.inventory-item", targetParts: ["*"], operations: ["read"] },
                {
                    scopeType: "universe.place.luau-execution-session",
                    targetParts: ["*"],
                    operations: ["write", "read"],
                },
                { scopeType: "memory-store.queue", targetParts: ["*"], operations: ["add", "dequeue", "discard"] },
                { scopeType: "memory-store.sorted-map", targetParts: ["*"], operations: ["write", "read"] },
                { scopeType: "memory-store", targetParts: ["*"], operations: ["flush", "get"] },
                { scopeType: "universe-messaging-service", targetParts: ["*"], operations: ["publish"] },
                { scopeType: "user.user-notification", targetParts: ["*"], operations: ["write"] },
                {
                    scopeType: "universe.ordered-data-store.scope.entry",
                    targetParts: ["*"],
                    operations: ["read", "write"],
                },
                { scopeType: "universe.secret", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "studio-evaluations", targetParts: ["*"], operations: ["create"] },
                { scopeType: "universe.subscription-product.subscription", targetParts: ["*"], operations: ["read"] },
                { scopeType: "universe", targetParts: ["*"], operations: ["write"] },
                { scopeType: "universe.place", targetParts: ["*"], operations: ["write"] },
                {
                    scopeType: "universe-datastores.objects",
                    targetParts: ["*"],
                    operations: ["read", "create", "update", "delete", "list"],
                },
                { scopeType: "universe-datastores.versions", targetParts: ["*"], operations: ["read", "list"] },
                {
                    scopeType: "universe-datastores.control",
                    targetParts: ["*"],
                    operations: ["create", "delete", "list", "snapshot"],
                },
                { scopeType: "universe.place.instance", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "universe-places", targetParts: ["*"], operations: ["write"] },
                { scopeType: "universe.user-restriction", targetParts: ["*"], operations: ["read", "write"] },
                { scopeType: "user.advanced", targetParts: ["*"], operations: ["read"] },
                { scopeType: "user.social", targetParts: ["*"], operations: ["read"] },
            ],
        },
    };

    const res = await axios.post(url, payload, {
        headers: {
            "x-csrf-token": csrfToken,
            "Content-Type": "application/json",
            Cookie: `.ROBLOSECURITY=${roblosecurity}`,
        },
        validateStatus: () => true, // Accept all status codes
    });

    if (res.status === 409) {
        // API key with the same name already exists, delete it first
        const deleteRes = await axios.delete(`${url}/${existingApiKeyId}`, {
            headers: {
                "x-csrf-token": csrfToken,
                Cookie: `.ROBLOSECURITY=${roblosecurity}`,
            },
            validateStatus: () => true, // Accept all status codes
        });
        if (deleteRes.status !== 200) {
            console.error("Failed to delete existing API key:", deleteRes.status, deleteRes.data);
            return;
        }
    }

    if (res.status !== 200) {
        console.error("Failed to create API key:", res.status, res.data);
        return;
    }

    /** @type {string} */
    const id = res.data.cloudAuthInfo.id;
    /** @type {number} */
    const userId = res.data.cloudAuthInfo.ownerId;
    /** @type {string} */
    const apiKey = res.data.apikeySecret;

    const dataToSave = {
        id,
        userId,
        apiKey,
        roblosecurity,
    };

    return dataToSave;
}

/**
 * Gets the starter place (root place) for the authenticated user.
 */
export async function getStarterPlace(context) {
    // Fetch the user's universes (experiences)
    const url = `https://apis.roblox.com/universes/v1/search?CreatorType=User&CreatorTargetId=${context.userId}&IsArchived=false&Surface=CreatorHubCreations&PageSize=50&SortParam=LastUpdated&SortOrder=Desc`;

    const res = await axios.get(url, {
        headers: {
            Cookie: `.ROBLOSECURITY=${context.roblosecurity}`,
        },
        validateStatus: () => true,
    });

    if (res.status !== 200) {
        console.error("Failed to fetch universes:", res.status, res.data);
        return;
    }

    const place = res.data.data.find((place) => place.name.includes("'s Place"));

    if (!place) {
        console.error("No starter place found.", res.data);
        return;
    }

    return {
        username: place.creatorName,
        id: place.id,
        name: place.name,
        rootPlaceId: place.rootPlaceId,
    };
}

/**
 * Gets the Roblox API context, creating it if it doesn't exist.
 * @param {string} roblosecurity The ROBLOSECURITY cookie value.
 * @returns {ReturnType<typeof createApiContext>} The API context.
 */
export async function getApiContext(roblosecurity) {
    let lastLoadContent = null;
    const load = async () => {
        const filePath = path.join(process.cwd(), ".robloxluauexecute");
        if (fs.existsSync(filePath)) {
            const fileData = fs.readFileSync(filePath, { encoding: "utf-8" });
            const apiKeyInfo = JSON.parse(fileData);
            if (apiKeyInfo && apiKeyInfo.roblosecurity === roblosecurity) {
                lastLoadContent = fileData;
                return apiKeyInfo;
            }
        }

        const apiKeyInfo = await createApiContext(roblosecurity);
        return apiKeyInfo;
    };

    const context = await load();

    if (!context.username || !context.placeId || !context.universeId) {
        const starterPlace = await getStarterPlace(context);
        if (starterPlace) {
            context.username = starterPlace.username;
            context.placeId = starterPlace.rootPlaceId;
            context.universeId = starterPlace.id;
        }
    }

    // Save the context to a file
    const contextString = JSON.stringify(context);
    if (lastLoadContent !== contextString) {
        const filePath = path.join(process.cwd(), ".robloxluauexecute");
        fs.writeFileSync(filePath, contextString, { encoding: "utf-8" });
    }

    return context;
}
